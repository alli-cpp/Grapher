<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Unit 7 CS4406 - Function Grapher</title>
  <style>
    #container {
      background: #222;
      width: 600px;
      height: 600px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

  <script type="text/javascript">
    // Set the canvas size and the scene
    var WIDTH = 600, HEIGHT = 600;
    
    // Camera settings
    var VIEW_ANGLE = 45, ASPECT = WIDTH / HEIGHT, NEAR = 0.001, FAR = 100;
    var container = document.getElementById('container');

    // Create WebGL renderer and scene
    var renderer = new THREE.WebGLRenderer();
    var scene = new THREE.Scene();
    var clock = new THREE.Clock();
    var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
    scene.add(camera);

    // Set camera position for better visibility
    camera.position.set(0, 5, 20);
    camera.up.set(0, 0, 1);

    // Set up the camera controls for mouse movement
    var cameraControls = new THREE.OrbitControls(camera, renderer.domElement);

    // Initialize the renderer and add it to the container
    renderer.setSize(WIDTH, HEIGHT);
    container.appendChild(renderer.domElement);

    // Function to generate a hyperbolic paraboloid (you can replace this with other functions)
    function f(x, y) {
      // Hyperbolic paraboloid equation: z = (x^2 / a^2) - (y^2 / b^2)
      var a = 2; // Define constants to scale the function
      var b = 2;
      return (Math.pow(x, 2) / Math.pow(a, 2)) - (Math.pow(y, 2) / Math.pow(b, 2));
    }

    // Create the geometry for the hyperbolic paraboloid
    var geometry = new THREE.Geometry();
    var step = 0.1; // Increments of 0.1 for x and y
    var min = -1, max = 1; // Range for x and y

    // Generate the vertices for the function graph
    for (var x = min; x <= max; x += step) {
      for (var y = min; y <= max; y += step) {
        var z = f(x, y);
        geometry.vertices.push(new THREE.Vector3(x, y, z));
      }
    }

    // Create faces for the mesh (simple grid)
    for (var i = 0; i < geometry.vertices.length - 1; i++) {
      if (i % 11 === 0) continue; // Skip last vertex of each row to avoid incorrect faces
      var v0 = geometry.vertices[i];
      var v1 = geometry.vertices[i + 1];
      var v2 = geometry.vertices[i + 11];
      var v3 = geometry.vertices[i + 12];

      // Create two faces per square grid
      geometry.faces.push(new THREE.Face3(i, i + 1, i + 11));
      geometry.faces.push(new THREE.Face3(i + 1, i + 12, i + 11));
    }

    // Compute normals for proper lighting
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    // Create the material and mesh for the function surface
    var material = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide, wireframe: true });
    var surface = new THREE.Mesh(geometry, material);
    scene.add(surface);

    // Add grid plane to provide reference
    var planeGeometry = new THREE.PlaneBufferGeometry(10, 10, 10, 10);
    var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x505050, wireframe: true, transparent: true, opacity: 0.25 });
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    scene.add(plane);

    // Add axis helper to show x, y, z directions
    function axisArrow(color) {
      var group = new THREE.Group();
      var arrowMaterial = new THREE.MeshPhongMaterial({ color: color, specular: 0x222222, shininess: 100 });
      var arrowCylinder = new THREE.CylinderGeometry(0.015, 0.015, 0.2, 32);
      var arrowCone = new THREE.ConeGeometry(0.05, 0.2, 40);
      var cylinder = new THREE.Mesh(arrowCylinder, arrowMaterial);
      var cone = new THREE.Mesh(arrowCone, arrowMaterial);
      
      cone.position.set(0, 0.275, 0);
      group.add(cylinder);
      group.add(cone);
      return group;
    }

    function axisHelper() {
      var group = new THREE.Group();
      var xAxis = axisArrow(new THREE.Color(0.0, 1.0, 0.0)); // Green for x-axis
      var yAxis = axisArrow(new THREE.Color(1.0, 0.0, 0.0)); // Red for y-axis
      var zAxis = axisArrow(new THREE.Color(0.0, 0.0, 1.0)); // Blue for z-axis
      xAxis.rotateZ(-Math.PI * 0.5);
      zAxis.rotateX(Math.PI * 0.5);
      group.add(xAxis);
      group.add(yAxis);
      group.add(zAxis);
      
      // Add origin cube
      var cubeGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
      var cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x808080, specular: 0x222222, shininess: 100 });
      var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      group.add(cube);

      return group;
    }

    var axisCamera = axisHelper();
    scene.add(axisCamera);

    // Add lighting
    var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    var sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
    sunLight.position.set(100, 100, 100);
    sunLight.castShadow = true;
    scene.add(sunLight);

    // Background color
    renderer.setClearColor(0x333333, 1.0);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      render();
    }

    function render() {
      cameraControls.update(); // Update camera controls
      renderer.render(scene, camera);
    }

    // Start the animation
    animate();

  </script>
</body>
</html>
